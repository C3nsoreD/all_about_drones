#!/usr/bin/env python3
"""
The drone object is a simulation of a real drone.
 - it should be able to move follow paths generated by the server
 - it should be able to connect to other drones.
 - it should be able to stop at points specificied by the server

"""
import socket
import random
import selectors

from datalink.Message import Message


class ClientMessage(Message):
    """
    Drone client is responsible for creating messages sent between drones and servers

    """
    def __init__(self, selector, sock, addr, request, data):
        super().__init__(selector, sock, addr, request)
        self.data = data

        def read(self):
            """ Overrides read() in Message cls
            Reads data and processes it according to the header options
            """
            self._read() # adds data to receive buffer

            if self._jsonheader_len is None:
                self.process_header()
            if self._jsonheader_len is not None:
                if self.jsonheader is None:
                    self.process_jsonresponse()
            if self.jsonheader:
                if self.response is None:
                    self.process_response()

    def write(self):
        # checks if there is queued Message
        if not self._request_queued:
            self.queued_request()

            self._write()

            if self._request_queued:
                if not self._send_buffer:
                    # nothing in the buffer so set selectors to read.
                    self._set_selectors_event_mask("r")

    def queued_request(self):
        content = self.request["content"]
        content_type = self.request["content-type"]
        content_encoding = self.request["encoding"]

        if content_type == "text/json":
            req = {
            "content_bytes": self._json_encode(content, content_encoding),
            "content_type": content_type,
            "content_encoding": content_encoding,
            }
        else:
            req = {
            "content_bytes": content,
            "content_type": content_type,
            "content_encoding": content_encoding,
            }
            message = self._create_message(**req)
            self._send_buffer += message
            self._request_queued = True


class Drone:
    def __init__(self, addr):
        self._id = self._get_id()
        self._addr = addr
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self._message = bytes(f"I am drone {self._id}", encoding='utf-8')
        self.sel = selectors.DefaultSelector()


    def _create_request(self, data):
        return dict(
            type="text/json",
            encoding="utf-8",
            content = b"" + data
        )

    # TODO: test this functionality
    # - it should only create a connection to the server.
    def start_connection(self):
        # try:
        #     self.soc.connect(self._addr)
        # except socket.error as e:
        #     print(f"Could not connect: {e}")
        self.sock.setblocking(False)
        self.sock.connect_ex(self._addr)
        # events = selectors.EVENT_READ | selectors.EVENT_WRITE
        # message = ClientMessage(self.sock, self._addr, self.sel, self.request)
        # self.sel.register(sock, events, data=message)
        #

    ## Function that send data to the drone or server
    def send_data(self):
        # try:
        #     # self.soc.connect(self._addr)
        #     print("# Trying to send data......")
        #     # data = self._data()
        #     self.soc.send(self._message)
        # except socket.error as e:
        #     print(f"Error sending data {e}")
        # print("# Data sent ... ")
        pass

    ## Function should handle recieved data
    def recieved(self, request):
        # """
        # Function that will recive commands
        # """
        # rec = str(self.soc.recv(3000), encoding='utf-8')
        # return rec
        pass

    def _get_id(self):
        """ Generates a random number
        """
        random.seed()
        return random.randint(1000, 9999)

    def __str__(self):
        return f"Drone with id {self._id}"


if __name__ == "__main__":
    address = ('localhost', 9999)
    # Client to connect to server
    # soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # soc.connect(address)
    #
    # # Send message
    # message = b'I am drone 2'
    #
    # print(f"Sending: {message}")
    #
    # len_sent = soc.send(message)
    # recived = str(soc.recv(1024), 'utf-8')

    client = Drone(address)
