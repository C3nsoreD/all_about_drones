#!/usr/bin/env python3
"""
The drone object is a simulation of a real drone.
 - it should be able to move follow paths generated by the server
 - it should be able to connect to other drones.
 - it should be able to stop at points specificied by the server

"""
import socket
import random
import selectors

from datalink.Message import Message


class ClientMessage(Message):
    """
    Drone client is responsible for creating messages sent between drones and servers
    """
    def __init__(self, selector, sock, addr, request):
        super().__init__(selector, sock, addr)
        # self.data = data
        self.request = request
        self._request_queued = False
        self.response = None

    def _process_response_json_content(self):
        content = self.response
        result = self.content.get("result")
        print(f"get result: {result}")

    def _process_response_binary_content(self):
        content = self.response
        print(f"got response {repr(content)}")

    def read(self):
        """ Overrides read() in Message cls
            Reads data and processes it according to the header options
        """
        self._read() # adds data to receive buffer

        if self._jsonheader_len is None:
            self.process_protoheader()

        if self._jsonheader_len is not None:
            if self.jsonheader is None:
                self.process_jsonheader()

        if self.jsonheader:
            if self.response is None:
                self.process_response()


    def write(self):
        # checks if there is queued Message
        if not self._request_queued:
            self.queued_request()

            self._write()
            if self._request_queued:
                if not self._send_buffer:
                    # nothing in the buffer so set selectors to read.
                    self._set_selectors_event_mask("r")

    def queued_request(self):
        content = self.request["content"]
        content_type = self.request["type"]
        content_encoding = self.request["encoding"]

        if content_type == "text/json":
            req = {
                "content_bytes": self._json_encode(content, content_encoding),
                "content_type": content_type,
                "content_encoding": content_encoding,
            }
        else:
            req = {
                "content_bytes": content,
                "content_type": content_type,
                "content_encoding": content_encoding,
            }
            message = self._create_message(**req)
            self._send_buffer += message
            self._request_queued = True

    def process_response(self):
        content_len = self.jsonheader["content-length"]
        if not len(self._recv_buffer) >= content_len:
            return
        data = self._recv_buffer[:content_len]
        self._recv_buffer = self._recv_buffer[content_len:]
        if self.jsonheader["content-type"] == "text/json":
            encoding = self.jsonheader["content-encoding"]
            self.response = self._json_decode(data, encoding)
            print("received response", repr(self.response), "from", self.addr)
            self._process_response_json_content()
        else:
            # Binary or unknown content-type
            self.response = data
            print(
                f'received {self.jsonheader["content-type"]} response from',
                self.addr,
            )
            self._process_response_binary_content()
        # Close when response has been processed
        self.close()


class Drone:
    def __init__(self, addr):
        self._id = self._get_id()
        self._addr = addr
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self._message = bytes(f"I am drone {self._id}", encoding='utf-8')
        self.sel = selectors.DefaultSelector()


    def _create_request(self, data):
        return dict(
            type="text/json",
            encoding="utf-8",
            content = b"" + data
        )

    # TODO: test this functionality
    # - it should only create a connection to the server.
    def start_connection(self):
        # try:
        #     self.soc.connect(self._addr)
        # except socket.error as e:
        #     print(f"Could not connect: {e}")
        self.sock.setblocking(False)
        self.sock.connect_ex(self._addr)
        # events = selectors.EVENT_READ | selectors.EVENT_WRITE
        # message = ClientMessage(self.sock, self._addr, self.sel, self.request)
        # self.sel.register(sock, events, data=message)
        #

    ## Function that send data to the drone or server
    def send_data(self):
        # try:
        #     # self.soc.connect(self._addr)
        #     print("# Trying to send data......")
        #     # data = self._data()
        #     self.soc.send(self._message)
        # except socket.error as e:
        #     print(f"Error sending data {e}")
        # print("# Data sent ... ")
        pass

    ## Function should handle recieved data
    def recieved(self, request):
        # """
        # Function that will recive commands
        # """
        # rec = str(self.soc.recv(3000), encoding='utf-8')
        # return rec
        pass

    def _get_id(self):
        """ Generates a random number
        """
        random.seed()
        return random.randint(1000, 9999)

    def __str__(self):
        return f"Drone with id {self._id}"
